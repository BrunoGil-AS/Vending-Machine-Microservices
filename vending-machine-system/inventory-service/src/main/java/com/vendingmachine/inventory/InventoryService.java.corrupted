package com.vendingmachine.inventory;

import com.vendingmachine.common.aop.annotation.Auditable;
import com.vendingmachine.common.aop.annotation.ExecutionTime;
import com.vendingmachine.inventory.kafka.KafkaProducerService;
import com.vendingmachine.inventory.kafka.InventoryKafkaEventService;
import com.vendingmachine.inventory.product.Product;
import com.vendingmachine.inventory.product.ProductRepository;
import com.vendingmachine.inventory.product.ProductUtils;
import com.vendingmachine.inventory.product.dto.PostProductDTO;
import com.vendingmachine.inventory.stock.Stock;
import com.vendingmachine.inventory.stock.StockRepository;
import io.github.resilience4j.bulkhead.annotation.Bulkhead;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
public class InventoryService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private StockRepository stockRepository;

    @Autowired
    private KafkaProducerService kafkaProducerService;

    @Autowired
    private InventoryKafkaEventService inventoryKafkaEventService;

    public List<Product> getAllProducts() {
        logger.debug("Retrieving all products");
        List<Product> products = productRepository.findAll();
        logger.info("Retrieved {} products", products.size());
        return products;
    }

    public Optional<Product> getProductById(Long productId) {
        logger.debug("Retrieving product with ID: {}", productId);
        return productRepository.findById(productId);
    }

    public Optional<Stock> getStockByProductId(Long productId) {
        logger.debug("Retrieving stock for product ID: {}", productId);
        Optional<Stock> stock = stockRepository.findByProductId(productId);
        if (stock.isPresent()) {
            logger.debug("Stock found for product ID: {}, quantity: {}", productId, stock.get().getQuantity());
        } else {
            logger.warn("No stock found for product ID: {}", productId);
        }
        return stock;
    }

    public Product addProduct(PostProductDTO product) {
        logger.info("Adding new product: {}", product.getName());
        Product newProduct = ProductUtils.convertToEntity(product);
        
        // Set default minThreshold if not provided
        Integer minThreshold = product.getMinThreshold();
        if (minThreshold == null) {
            minThreshold = 5; // Default minimum threshold
        }
        
        Stock stock = Stock.builder()
                    .product(newProduct)
                    .quantity(product.getQuantity())
                    .minThreshold(minThreshold)
                    .build();
        newProduct.setStock(stock);
        productRepository.save(newProduct);
        stockRepository.save(stock);
        logger.info("Product added successfully with ID: {}, initial stock: {}", newProduct.getId(), product.getQuantity());

        // Log stock status after product creation
        if (stock.getQuantity() <= 0) {
            logger.warn("Product ID: {} added with out of stock", newProduct.getId());
        } else if (stock.getQuantity() < stock.getMinThreshold()) {
            logger.warn("Product ID: {} added with low stock. Current: {}, Threshold: {}",
                       newProduct.getId(), stock.getQuantity(), stock.getMinThreshold());
        }

        // Publish stock update event for initial stock with complete payload
        inventoryKafkaEventService.publishStockUpdateEventWithCompleteData(stock, "INITIAL_STOCK");
        logger.info("Published initial stock update event with complete data for product: {}", newProduct.getId());

        // Publish low stock alert if applicable
        if (stock.getQuantity() < stock.getMinThreshold() && stock.getQuantity() > 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(stock, "LOW_STOCK");
            logger.info("Published low stock alert event with complete data for new product: {}", newProduct.getId());
        } else if (stock.getQuantity() <= 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(stock, "OUT_OF_STOCK");
            logger.warn("Published out of stock alert event with complete data for new product: {}", newProduct.getId());
        }

        return newProduct;
    }

    public Product updateProduct(Long productId, PostProductDTO productDTO) {
        logger.info("Updating product with ID: {}", productId);
        
        // Find existing product
        Product existingProduct = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("Product not found with id: " + productId));
        
        // Update product fields
        existingProduct.setName(productDTO.getName());
        existingProduct.setPrice(productDTO.getPrice());
        existingProduct.setDescription(productDTO.getDescription());
        
        // Update associated stock
        Stock existingStock = stockRepository.findByProductId(productId)
                .orElseThrow(() -> new RuntimeException("Stock not found for product id: " + productId));
        
        int previousQuantity = existingStock.getQuantity();
        existingStock.setQuantity(productDTO.getQuantity());
        
        // Set default minThreshold if not provided
        Integer minThreshold = productDTO.getMinThreshold();
        if (minThreshold == null) {
            minThreshold = existingStock.getMinThreshold() != null ? existingStock.getMinThreshold() : 5;
        }
        existingStock.setMinThreshold(minThreshold);
        
        // Save both entities
        Product updatedProduct = productRepository.save(existingProduct);
        Stock updatedStock = stockRepository.save(existingStock);
        
        logger.info("Product updated successfully with ID: {}. Previous quantity: {}, New quantity: {}, Min threshold: {}",
                   productId, previousQuantity, updatedStock.getQuantity(), updatedStock.getMinThreshold());

        // Determine change type and quantity changed
        Integer quantityChanged = Math.abs(updatedStock.getQuantity() - previousQuantity);
        String changeType;
        if (updatedStock.getQuantity() > previousQuantity) {
            changeType = "INCREASE";
        } else if (updatedStock.getQuantity() < previousQuantity) {
            changeType = "DECREASE";
        } else {
            changeType = "NO_CHANGE";
        }

        // Publish stock update event with complete payload
        inventoryKafkaEventService.publishStockUpdateEventWithCompleteData(
            productId,
            updatedProduct.getName(),
            previousQuantity,
            updatedStock.getQuantity(),
            quantityChanged,
            changeType,
            "Product stock updated via updateProduct",
            null  // relatedTransactionId (not applicable for manual updates)
        );
        logger.info("Published stock update event with complete data for product: {}", productId);

        // Publish low stock alert if applicable
        if (updatedStock.getQuantity() < updatedStock.getMinThreshold() && updatedStock.getQuantity() > 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(updatedStock, "LOW_STOCK");Time(operation = "updateStock", warningThreshold = 800, detailed = true)
    public Stock updateStock(Long productId, Integer quantity) {
        logger.info("Updating stock for product ID: {}, quantity change: {}", productId, quantity);
        Stock existingStock = stockRepository.findByProductId(productId)
                .orElseThrow(() -> new RuntimeException("Stock not found for product id: " + productId));
        if (existingStock.getMinThreshold() == null) {
            existingStock.setMinThreshold(5); // Default value for existing stocks
        }
        int previousQuantity = existingStock.getQuantity();
        existingStock.setQuantity(existingStock.getQuantity() + quantity);
        Stock updatedStock = stockRepository.save(existingStock);

        logger.info("Stock updated for product ID: {}. Previous quantity: {}, New quantity: {}, Min threshold: {}",
                   productId, previousQuantity, updatedStock.getQuantity(), updatedStock.getMinThreshold());

        // Determine change type and quantity changed
        Integer quantityChanged = Math.abs(updatedStock.getQuantity() - previousQuantity);
        String changeType;
        if (updatedStock.getQuantity() > previousQuantity) {
            changeType = "INCREASE";
        } else if (updatedStock.getQuantity() < previousQuantity) {
            changeType = "DECREASE";
        } else {
            changeType = "NO_CHANGE";
        }

        // Publish stock update event with complete payload
        inventoryKafkaEventService.publishStockUpdateEventWithCompleteData(
            productId,
            existingStock.getProduct().getName(),
            previousQuantity,
            updatedStock.getQuantity(),
            quantityChanged,
            changeType,
            "Manual stock quantity update",
            null  // relatedTransactionId (not applicable for manual updates)
        );
        logger.info("Published stock update event with complete data for product: {}", productId);

        // Publish low stock alert if applicable
        if (updatedStock.getQuantity() < updatedStock.getMinThreshold() && updatedStock.getQuantity() > 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(
                productId,
                existingStock.getProduct().getName(),
                updatedStock.getQuantity(),
                updatedStock.getMinThreshold(),
                "LOW_STOCK"
            );
            logger.info("Published low stock alert event with complete data for product: {}", productId);
        } else if (updatedStock.getQuantity() <= 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(
                productId,
                existingStock.getProduct().getName(),
                updatedStock.getQuantity(),
                updatedStock.getMinThreshold(),
                "OUT_OF_STOCK"
            );
            logger.warn("Published out of stock alert event with complete data for product: {}", productId);
        }

        return updatedStock;
    }

    public Stock updateStock(Long productId, Stock stock) {
        logger.info("Updating stock details for product ID: {}, new quantity: {}, new threshold: {}",
                   productId, stock.getQuantity(), stock.getMinThreshold());
        Stock existingStock = stockRepository.findByProductId(productId)
                .orElseThrow(() -> new RuntimeException("Stock not found for product id: " + productId));
        if (existingStock.getMinThreshold() == null) {
            existingStock.setMinThreshold(5); // Default value for existing stocks
        }
        int previousQuantity = existingStock.getQuantity();
        existingStock.setQuantity(stock.getQuantity());
        
        // Set default minThreshold if not provided
        Integer minThreshold = stock.getMinThreshold();
        if (minThreshold == null) {
            minThreshold = existingStock.getMinThreshold() != null ? existingStock.getMinThreshold() : 5;
        }
        existingStock.setMinThreshold(minThreshold);
        
        Stock updatedStock = stockRepository.save(existingStock);
        logger.info("Stock details updated for product ID: {}. Previous quantity: {}, New quantity: {}, Min threshold: {}",
                   productId, previousQuantity, updatedStock.getQuantity(), updatedStock.getMinThreshold());

        // Determine change type and quantity changed
        Integer quantityChanged = Math.abs(updatedStock.getQuantity() - previousQuantity);
        String changeType;
        if (updatedStock.getQuantity() > previousQuantity) {
            changeType = "INCREASE";
        } else if (updatedStock.getQuantity() < previousQuantity) {
            changeType = "DECREASE";
        } else {
            changeType = "NO_CHANGE";
        }

        // Publish stock update event with complete payload
        inventoryKafkaEventService.publishStockUpdateEventWithCompleteData(
            productId,
            existingStock.getProduct().getName(),
            previousQuantity,
            updatedStock.getQuantity(),
            quantityChanged,
            changeType,
            "Stock details updated (quantity and threshold)",
            null  // relatedTransactionId (not applicable for manual updates)
        );
        logger.info("Published stock update event with complete data for product: {}", productId);

        // Publish low stock alert if applicable
        if (updatedStock.getQuantity() < updatedStock.getMinThreshold() && updatedStock.getQuantity() > 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(
                productId,
                existingStock.getProduct().getName(),
                updatedStock.getQuantity(),
                updatedStock.getMinThreshold(),
                "LOW_STOCK"
            );
            logger.info("Published low stock alert event with complete data for product: {}", productId);
        } else if (updatedStock.getQuantity() <= 0) {
            inventoryKafkaEventService.publishLowStockAlertWithCompleteData(
                productId,
                existingStock.getProduct().getName(),
                updatedStock.getQuantity(),
                updatedStock.getMinThreshold(),
                "OUT_OF_STOCK"
            );
            logger.warn("Published out of stock alert event with complete data for product: {}", productId);
        }

        return updatedStock;
    }

    @ExecutionTime(operation = "checkInventoryAvailability", warningThreshold = 500)
    public boolean checkInventoryAvailability(List<Map<String, Object>> items) {
        logger.debug("Checking inventory availability for {} items", items.size());

        for (Map<String, Object> item : items) {
            Long productId = ((Number) item.get("productId")).longValue();
            Integer quantity = ((Number) item.get("quantity")).intValue();

            logger.debug("Checking availability for product ID: {}, requested quantity: {}", productId, quantity);

            Optional<Stock> stockOpt = getStockByProductId(productId);
            if (stockOpt.isEmpty()) {
                logger.warn("Product ID: {} not found in inventory", productId);
                return false;
            }

            Stock stock = stockOpt.get();
            if (stock.getQuantity() < quantity) {
                logger.warn("Insufficient stock for product ID: {}. Available: {}, Requested: {}",
                           productId, stock.getQuantity(), quantity);
                return false;
            }
        }

        logger.info("All items are available in inventory");
        return true;
    }

    /**
     * Check availability for multiple products and return detailed information per product.
     * 
     * @param items List of items with productId and quantity
     * @return Map of productId to availability details (available, quantity, reason)
     */
    @Bulkhead(name = "inventory-checks", fallbackMethod = "checkMultipleAvailabilityFallback", type = Bulkhead.Type.SEMAPHORE)
    public Map<Long, Map<String, Object>> checkMultipleAvailability(List<Map<String, Object>> items) {
        logger.debug("Checking detailed availability for {} items", items.size());
        
        Map<Long, Map<String, Object>> results = new java.util.HashMap<>();
        
        for (Map<String, Object> item : items) {
            Long productId = ((Number) item.get("productId")).longValue();
            Integer requestedQuantity = ((Number) item.get("quantity")).intValue();
            
            logger.debug("Checking availability for product ID: {}, requested quantity: {}", 
                        productId, requestedQuantity);
            
            Optional<Stock> stockOpt = getStockByProductId(productId);
            
            if (stockOpt.isEmpty()) {
                logger.warn("Product ID: {} not found in inventory", productId);
                results.put(productId, Map.of(
                    "available", false,
                    "quantity", 0,
                    "reason", "Product not found"
                ));
                continue;
            }
            
            Stock stock = stockOpt.get();
            int availableQuantity = stock.getQuantity();
            
            if (availableQuantity >= requestedQuantity) {
                logger.debug("Product ID: {} has sufficient stock. Available: {}, Requested: {}", 
                            productId, availableQuantity, requestedQuantity);
                results.put(productId, Map.of(
                    "available", true,
                    "quantity", availableQuantity,
                    "reason", "In stock"
                ));
            } else {
                logger.warn("Product ID: {} has insufficient stock. Available: {}, Requested: {}", 
                           productId, availableQuantity, requestedQuantity);
                results.put(productId, Map.of(
                    "available", false,
                    "quantity", availableQuantity,
                    "reason", "Insufficient stock"
                ));
            }
        }
        
        logger.info("Availability check completed for {} items", items.size());
        return results;
    }

    public void deleteProduct(Long productId) {
        logger.info("Deleting product with ID: {}", productId);
        if (!productRepository.existsById(productId)) {
            logger.error("Product with ID: {} not found for deletion", productId);
            throw new RuntimeException("Product not found with id: " + productId);
        }
        Optional<Stock> stockOpt = stockRepository.findByProductId(productId);
        Stock stock = stockOpt.orElse(null);
        if (stock != null) {
            stockRepository.delete(stock);
            logger.debug("Stock for product ID: {} deleted", productId);
        } else {
            logger.warn("No stock found for product ID: {} during deletion", productId);
        }
        productRepository.deleteById(productId);
        logger.info("Product with ID: {} deleted successfully", productId);
    }

    // Fallback methods for Bulkhead pattern

    /**
     * Fallback method when inventory checks bulkhead is full
     */
    private Map<Long, Map<String, Object>> checkMultipleAvailabilityFallback(List<Map<String, Object>> items, Exception ex) {
        logger.error("Inventory checks bulkhead full for {} items. Error: {}", items.size(), ex.getMessage());
        logger.warn("Inventory service at capacity - marking all items as unavailable");
        
        Map<Long, Map<String, Object>> results = new java.util.HashMap<>();
        for (Map<String, Object> item : items) {
            Long productId = ((Number) item.get("productId")).longValue();
            results.put(productId, Map.of(
                "available", false,
                "reason", "Inventory service at capacity - please retry",
                "fallback", true,
                "requestedQuantity", item.get("quantity")
            ));
        }
        return results;
    }

    /**
     * Fallback method when stock updates bulkhead is full
     */
    private Stock updateStockFallback(Long productId, Integer quantity, Exception ex) {
        logger.error("Stock updates bulkhead full for product {}. Quantity: {}. Error: {}", 
                productId, quantity, ex.getMessage());
        logger.warn("Stock update service at capacity - rejecting stock update for product {}", productId);
        
        // Return existing stock without changes to indicate failure
        Optional<Stock> existingStock = stockRepository.findByProductId(productId);
        if (existingStock.isPresent()) {
            return existingStock.get();
        } else {
            // Create a placeholder stock to indicate the failure
            Stock failureStock = Stock.builder()
                .product(null) // Will be null to indicate failure
                .quantity(-1)  // Negative quantity to indicate failure
                .minThreshold(0)
                .build();
            return failureStock;
        }
    }
}
